const snarkjs = require("snarkjs");
const fs = require("fs");
const path = require("path");

/**
 * ZK Proof Verifier for Emergency Guardian System
 * Verifies proofs generated by the ZKProofGenerator
 */

class ZKProofVerifier {
  constructor() {
    this.keysPath = path.join(__dirname, "..", "keys");
    this.verificationKeys = {};
    this.loadVerificationKeys();
  }

  /**
   * Load all verification keys
   */
  loadVerificationKeys() {
    const circuits = ["identity", "emergency", "authorization"];

    for (const circuit of circuits) {
      try {
        const vkeyPath = path.join(
          this.keysPath,
          circuit,
          "verification_key.json"
        );

        if (fs.existsSync(vkeyPath)) {
          this.verificationKeys[circuit] = JSON.parse(
            fs.readFileSync(vkeyPath)
          );
          console.log(`âœ… Loaded verification key for ${circuit}`);
        } else {
          console.warn(
            `âš ï¸  Verification key not found for ${circuit}: ${vkeyPath}`
          );
        }
      } catch (error) {
        console.error(
          `âŒ Error loading verification key for ${circuit}:`,
          error.message
        );
      }
    }
  }

  /**
   * Verify identity proof
   * @param {Object} proof - The proof to verify
   * @param {Array} publicSignals - Public signals
   * @returns {Object} Verification result with details
   */
  async verifyIdentityProof(proof, publicSignals) {
    console.log("ðŸ” Verifying guardian identity proof...");

    try {
      const vKey = this.verificationKeys.identity;
      if (!vKey) {
        throw new Error("Identity verification key not loaded");
      }

      // Verify the proof
      const isValid = await snarkjs.groth16.verify(vKey, publicSignals, proof);

      // Extract and validate public signals
      const [nullifierHash, commitment, validityFlag] = publicSignals;

      const result = {
        isValid: isValid,
        circuitType: "identity",
        publicSignals: {
          nullifierHash: nullifierHash,
          commitment: commitment,
          isValid: validityFlag,
        },
        timestamp: new Date().toISOString(),
        verificationDetails: {
          proofStructure: this._validateProofStructure(proof),
          publicSignalCount: publicSignals.length,
          expectedSignalCount: 3,
        },
      };

      // Additional validation
      if (publicSignals.length !== 3) {
        result.warnings = [
          `Expected 3 public signals, got ${publicSignals.length}`,
        ];
      }

      console.log(
        `${isValid ? "âœ…" : "âŒ"} Identity proof verification ${
          isValid ? "passed" : "failed"
        }`
      );

      return result;
    } catch (error) {
      console.error("âŒ Error verifying identity proof:", error.message);
      return {
        isValid: false,
        error: error.message,
        circuitType: "identity",
        timestamp: new Date().toISOString(),
      };
    }
  }

  /**
   * Verify emergency state proof
   * @param {Object} proof - The proof to verify
   * @param {Array} publicSignals - Public signals
   * @returns {Object} Verification result with details
   */
  async verifyEmergencyProof(proof, publicSignals) {
    console.log("ðŸ” Verifying emergency state proof...");

    try {
      const vKey = this.verificationKeys.emergency;
      if (!vKey) {
        throw new Error("Emergency verification key not loaded");
      }

      // Verify the proof
      const isValid = await snarkjs.groth16.verify(vKey, publicSignals, proof);

      // Extract and validate public signals
      const [emergencyHash, commitment, validityFlag, severityCommitment] =
        publicSignals;

      const result = {
        isValid: isValid,
        circuitType: "emergency",
        publicSignals: {
          emergencyHash: emergencyHash,
          commitment: commitment,
          isValid: validityFlag,
          severityCommitment: severityCommitment,
        },
        timestamp: new Date().toISOString(),
        verificationDetails: {
          proofStructure: this._validateProofStructure(proof),
          publicSignalCount: publicSignals.length,
          expectedSignalCount: 4,
        },
      };

      // Additional validation
      if (publicSignals.length !== 4) {
        result.warnings = [
          `Expected 4 public signals, got ${publicSignals.length}`,
        ];
      }

      console.log(
        `${isValid ? "âœ…" : "âŒ"} Emergency proof verification ${
          isValid ? "passed" : "failed"
        }`
      );

      return result;
    } catch (error) {
      console.error("âŒ Error verifying emergency proof:", error.message);
      return {
        isValid: false,
        error: error.message,
        circuitType: "emergency",
        timestamp: new Date().toISOString(),
      };
    }
  }

  /**
   * Verify authorization proof
   * @param {Object} proof - The proof to verify
   * @param {Array} publicSignals - Public signals
   * @returns {Object} Verification result with details
   */
  async verifyAuthorizationProof(proof, publicSignals) {
    console.log("ðŸ” Verifying authorization proof...");

    try {
      const vKey = this.verificationKeys.authorization;
      if (!vKey) {
        throw new Error("Authorization verification key not loaded");
      }

      // Verify the proof
      const isValid = await snarkjs.groth16.verify(vKey, publicSignals, proof);

      // Extract and validate public signals
      const [authHash, operationCommitment, guardianCommitment, isAuthorized] =
        publicSignals;

      const result = {
        isValid: isValid,
        circuitType: "authorization",
        publicSignals: {
          authHash: authHash,
          operationCommitment: operationCommitment,
          guardianCommitment: guardianCommitment,
          isAuthorized: isAuthorized,
        },
        timestamp: new Date().toISOString(),
        verificationDetails: {
          proofStructure: this._validateProofStructure(proof),
          publicSignalCount: publicSignals.length,
          expectedSignalCount: 4,
        },
      };

      // Additional validation
      if (publicSignals.length !== 4) {
        result.warnings = [
          `Expected 4 public signals, got ${publicSignals.length}`,
        ];
      }

      console.log(
        `${isValid ? "âœ…" : "âŒ"} Authorization proof verification ${
          isValid ? "passed" : "failed"
        }`
      );

      return result;
    } catch (error) {
      console.error("âŒ Error verifying authorization proof:", error.message);
      return {
        isValid: false,
        error: error.message,
        circuitType: "authorization",
        timestamp: new Date().toISOString(),
      };
    }
  }

  /**
   * Batch verify multiple proofs
   * @param {Array} proofRequests - Array of proof verification requests
   * @returns {Array} Array of verification results
   */
  async batchVerifyProofs(proofRequests) {
    console.log(`ðŸ”„ Verifying ${proofRequests.length} proofs in batch...`);

    const results = [];

    for (const request of proofRequests) {
      try {
        let result;

        switch (request.type) {
          case "identity":
            result = await this.verifyIdentityProof(
              request.proof,
              request.publicSignals
            );
            break;
          case "emergency":
            result = await this.verifyEmergencyProof(
              request.proof,
              request.publicSignals
            );
            break;
          case "authorization":
            result = await this.verifyAuthorizationProof(
              request.proof,
              request.publicSignals
            );
            break;
          default:
            throw new Error(`Unknown proof type: ${request.type}`);
        }

        results.push(result);
      } catch (error) {
        results.push({
          isValid: false,
          error: error.message,
          circuitType: request.type,
          timestamp: new Date().toISOString(),
        });
      }
    }

    const successCount = results.filter((r) => r.isValid).length;
    console.log(
      `âœ… Batch verification completed: ${successCount}/${results.length} proofs valid`
    );

    return results;
  }

  /**
   * Get verification statistics
   * @returns {Object} Statistics about loaded verification keys
   */
  getVerificationStats() {
    const loadedKeys = Object.keys(this.verificationKeys);
    const expectedKeys = ["identity", "emergency", "authorization"];
    const missingKeys = expectedKeys.filter((key) => !loadedKeys.includes(key));

    return {
      totalExpected: expectedKeys.length,
      totalLoaded: loadedKeys.length,
      loadedKeys: loadedKeys,
      missingKeys: missingKeys,
      isFullyLoaded: missingKeys.length === 0,
      lastUpdated: new Date().toISOString(),
    };
  }

  /**
   * Reload verification keys
   */
  reloadVerificationKeys() {
    console.log("ðŸ”„ Reloading verification keys...");
    this.verificationKeys = {};
    this.loadVerificationKeys();

    const stats = this.getVerificationStats();
    console.log(
      `âœ… Reloaded ${stats.totalLoaded}/${stats.totalExpected} verification keys`
    );

    return stats;
  }

  // Private helper methods
  _validateProofStructure(proof) {
    const requiredFields = ["pi_a", "pi_b", "pi_c"];
    const missingFields = requiredFields.filter(
      (field) => !proof.hasOwnProperty(field)
    );

    return {
      isValid: missingFields.length === 0,
      missingFields: missingFields,
      hasCorrectStructure:
        Array.isArray(proof.pi_a) &&
        Array.isArray(proof.pi_b) &&
        Array.isArray(proof.pi_c),
    };
  }
}

module.exports = { ZKProofVerifier };
